{
  "version": 3,
  "sources": ["../../src/crypto/index.ts"],
  "sourcesContent": ["import crypto from \"crypto\";\n\nimport config from \"../config\";\n\n\nexport interface JWK {\n    kid: string\n    alg: \"EdDSA\"\n    use?: \"sig\"\n    kty: \"OKP\"\n    crv: \"Ed25519\"\n    x: string\n}\n\nexport const fromRawPrivateKey = async (rawPrivateKey: Buffer) => {\n    return crypto.createPrivateKey({format: \"der\", key: rawPrivateKey, type: \"pkcs8\"});\n};\n\nexport const createKeyPair = async (): Promise<{privateKey: crypto.KeyObject, publicKey: crypto.KeyObject}> => {\n    const privateKey = await fromRawPrivateKey(config.PRIVATE_KEY);\n    const publicKey = crypto.createPublicKey(privateKey);\n    return {privateKey, publicKey};\n};\n\nexport const sign = async (message: string): Promise<string> => {\n    const {privateKey} = await createKeyPair();\n    const signature = crypto.sign(null, Buffer.from(message), privateKey);\n    return signature.toString(\"hex\");\n};\n\n\nexport const verify = async (message: string, signature: string): Promise<boolean> => {\n    const {publicKey} = await createKeyPair();\n    return crypto.verify(null, Buffer.from(message), publicKey, Buffer.from(signature, \"hex\"));\n};\n\nexport const asPEM = async (): Promise<string> => {\n    const {publicKey} = await createKeyPair();\n    return publicKey.export({\n        format: \"pem\",\n        type: \"spki\"\n    }).toString();\n};\n\nexport const asJWK = async (): Promise<JWK> => {\n    const {publicKey} = await createKeyPair();\n    const jwk = publicKey.export({\n        format: \"jwk\"\n    });\n    if (jwk.x === undefined) {\n        throw new Error(\"Failed to derive public key\");\n    }\n\n    const keyId = crypto.createHash(\"sha256\").update(jwk.x).digest(\"base64\");\n    if (!keyId.trim()) {\n        throw new Error(\"KeyId cannot be empty\");\n    }\n\n    if (jwk.crv !== \"Ed25519\" || jwk.kty !== \"OKP\" || !jwk.x) {\n        throw new Error(\"Key is not EdDSA-Ed25519\");\n    }\n    return {\n        alg: \"EdDSA\",\n        kid: keyId,\n        kty: jwk.kty,\n        crv: jwk.crv,\n        x: jwk.x\n    };\n};\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,WAAAE,EAAA,UAAAC,EAAA,kBAAAC,EAAA,sBAAAC,EAAA,SAAAC,EAAA,WAAAC,IAAA,eAAAC,EAAAR,GAAA,IAAAS,EAAmB,qBAEnBC,EAAmB,wBAYZ,MAAML,EAAoB,MAAOM,GAC7B,EAAAC,QAAO,iBAAiB,CAAC,OAAQ,MAAO,IAAKD,EAAe,KAAM,OAAO,CAAC,EAGxEP,EAAgB,SAAkF,CAC3G,MAAMS,EAAa,MAAMR,EAAkB,EAAAS,QAAO,WAAW,EACvDC,EAAY,EAAAH,QAAO,gBAAgBC,CAAU,EACnD,MAAO,CAAC,WAAAA,EAAY,UAAAE,CAAS,CACjC,EAEaT,EAAO,MAAOU,GAAqC,CAC5D,KAAM,CAAC,WAAAH,CAAU,EAAI,MAAMT,EAAc,EAEzC,OADkB,EAAAQ,QAAO,KAAK,KAAM,OAAO,KAAKI,CAAO,EAAGH,CAAU,EACnD,SAAS,KAAK,CACnC,EAGaN,EAAS,MAAOS,EAAiBC,IAAwC,CAClF,KAAM,CAAC,UAAAF,CAAS,EAAI,MAAMX,EAAc,EACxC,OAAO,EAAAQ,QAAO,OAAO,KAAM,OAAO,KAAKI,CAAO,EAAGD,EAAW,OAAO,KAAKE,EAAW,KAAK,CAAC,CAC7F,EAEad,EAAQ,SAA6B,CAC9C,KAAM,CAAC,UAAAY,CAAS,EAAI,MAAMX,EAAc,EACxC,OAAOW,EAAU,OAAO,CACpB,OAAQ,MACR,KAAM,MACV,CAAC,EAAE,SAAS,CAChB,EAEab,EAAQ,SAA0B,CAC3C,KAAM,CAAC,UAAAa,CAAS,EAAI,MAAMX,EAAc,EAClCc,EAAMH,EAAU,OAAO,CACzB,OAAQ,KACZ,CAAC,EACD,GAAIG,EAAI,IAAM,OACV,MAAM,IAAI,MAAM,6BAA6B,EAGjD,MAAMC,EAAQ,EAAAP,QAAO,WAAW,QAAQ,EAAE,OAAOM,EAAI,CAAC,EAAE,OAAO,QAAQ,EACvE,GAAI,CAACC,EAAM,KAAK,EACZ,MAAM,IAAI,MAAM,uBAAuB,EAG3C,GAAID,EAAI,MAAQ,WAAaA,EAAI,MAAQ,OAAS,CAACA,EAAI,EACnD,MAAM,IAAI,MAAM,0BAA0B,EAE9C,MAAO,CACH,IAAK,QACL,IAAKC,EACL,IAAKD,EAAI,IACT,IAAKA,EAAI,IACT,EAAGA,EAAI,CACX,CACJ",
  "names": ["crypto_exports", "__export", "asJWK", "asPEM", "createKeyPair", "fromRawPrivateKey", "sign", "verify", "__toCommonJS", "import_crypto", "import_config", "rawPrivateKey", "crypto", "privateKey", "config", "publicKey", "message", "signature", "jwk", "keyId"]
}
